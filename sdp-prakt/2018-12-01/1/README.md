# Контролно 1

2018-12-02  
СДП-практикум

## Вариант 1

* За всяка от задачите трябва да предадете точно един .cpp файл.
* Имената на файловете трябва да бъдат `1.cpp`, `2.cpp` и `3.cpp`.

**Задача 1.** Напишете функция, която приема указател към корена на двоично дърво и проверява дали то е пълно, двоично наредено дърво. По-долу са дадени прототипът на функцията и представянето на възлите на дървото.
```cpp
bool isComplete(Node *root);

struct Node {
    int value;
    Node *left, *right;
}
```

**Задача 2.** Напишете функция която приема (1) указател към корена на дърво с произволен брой деца и (2) цяло положително число N. Функцията трябва да върне вектор от всички елементи на дървото които са на разстояние N от корена. По-долу са дадени прототипът на функцията и представянето на възлите на дървото.
```cpp
std::vector<Node*> getNthFront(Node *root, int level);

struct Node {
    int value;
    std::vector<Node> children;
}
```

**Задача 3.** Имплементирайте функция която получава указател към корена на двоично дърво от цели числа (не-наредено) и две цели числа A и B. Функцията трябва да върне вектор от всички елементи които се намират в пътя от A до B. Ако такъв не съществува, върнете празен вектор. Считаме, че в дървото няма повторения на елементи. По-долу са дадени прототипът на функцията и представянето на възлите на дървото.
```cpp
std::vector<int> getPath(Node *root, int A, int B);

struct Node {
    int value;
    Node *left, *right;
};
```

## Вариант 2

* За всяка от задачите трябва да предадете точно един .cpp файл.
* Имената на файловете трябва да бъдат `1.cpp`, `2.cpp` и `3.cpp`.

**Задача 1.** Напишете функция, която приема указател към корена на двоично дърво и връща указател към най-голямото му (с най-много елементи) двоично наредено поддърво. По-долу са дадени прототипът на функцията и представянето на възлите на дървото.
```cpp
Node * getLargestBstSubtree(Node *root);

struct Node {
    int value;
    Node *left, *right;
}
```

**Задача 2.** Напишете функция която приема указател към корена на дърво с произволен брой деца и две цели, положителни числа A и B. Функцията трябва да върне вектор от всички елементи на дървото, които са стойности в интервала [A, B]. По-долу са дадени прототипът на функцията и представянето на възлите на дървото.
```cpp
std::vector<Node*> getBetween(Node *root, int A, int B);

struct Node {
    int value;
    std::vector<Node> children;
}
```

**Задача 3.** Имплементирайте функция която получава указател към корена на двоично дърво от цели числа (не-наредено) и две цели числа A и B. Ако A и B се срещат в дървото, функцията трябва да върне указател към най-близкия им общ родител. Ако такъв не съществува, върнете nullptr. Считаме, че всеки елемент в дървото се среща само по веднъж. По-долу са дадени прототипът на функцията и представянето на възлите на дървото.
```cpp
Node* getCommonAncestor(Node *root, int A, int B);

struct Node {
    int value;
    Node *left, *right;
};
```