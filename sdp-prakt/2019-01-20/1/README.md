# Контролно 2

2019-01-21  
СДП-практикум

## Вариант 1

В задачите можете да използвате наготово контейнерите от STL (`array`, `vector`, `list`, `forward_list`, `stack` и `queue`, `map`, `set`, `unordered_set` и `unordered_map`). Всички останали структури от данни трябва да реализирате сами. Можете да използвате и помощните класове `pair` и `tuple`.

В случай, че ви потрябва хешираща функция, копирайте дадения по-долу код и използвайте наготово `getHash`. За да се компилира кодът, включете заглавния файл `<functional>`. Забележете, че връщаната стойност е от тип `size_t` (може да бъде произволно голяма). Ако трябва да я ограничите, за целите на изпита е достатъчно да я вземете по модул.


    template <typename T>
    size_t getHash(const T &element) {
        return std::hash<T>()(element);
    }

    size_t getHash(const char *str) {
        return std::hash<std::string>()(str);
    }


**Задача 1**. Напишете функция която приема два аргумента:

* Корен на двоично, не наредено дърво с елементи цели числа
* Цяло число N

Вашата функция трябва да изтрие всички поддървета, които съдържат **само** възли със стойност N.  Напишете кратка програма, която демонстрира работата на функцията върху примерно дърво. По-долу са дадени представянето на дървото и прототипа на функцията, която трябва да реализирате. Те трябва да са точно такива, както са показани тук.

    struct Node {
        Node *left, *right;
        int value;
    };

    void removeSubtrees(Node *root, int value);


**Задача 2**. Напишете програма, която на входа си получава описанието на граф. Този граф е неориентиран, без тегла на дъгите си. След него ще бъдат въведени индексите на три от върховете му (A, B и C). Вашата програма трябва да отпечата на стандартния изход най-късия път от A до C, който минава през B.

На входа на програмата ще се подадат, в следния ред:
* Цяло число N – брой върхове в графа (всеки от тях е число между 0 до N);
* Цяло число К – брой на ребрата в графа;
* K на брой реда, всеки от които съдържа две числа – индексите на върхове, между които има ребро в графа;
* Три числа A, B и C – индексите на върховете в графа, между които трябва да се намери път.


**Бонус задача** _(за онези от вас, който на първото контролно имат резултат <= 5т., тази задача носи до 2т.)_

Имплементирайте функция, която получава като аргумент корена на двоично дърво и определя дали то е двоично наредено дърво. Напишете кратка програма, която демонстрира работата на функцията върху примерно дърво. В нея покажете как функцията реагира на поне два положителни и един отрицателен пример.
По-долу са дадени представянето на дървото и прототипа на функцията, която трябва да реализирате. Те трябва да са точно такива, както са показани тук.

    struct Node {
        Node *left, *right;
        int value;
    };

    bool isBst(Node* root);

----

_Упътване: За създаването на примерни дървета не е нужно да разписвате клас или функции. Можете да се възползвате от това, че можете да ги създадете при инициализацията:_

    Node* test_tree = new Node{ 11, new Node { 23, new Node { 42 }, nullptr },
                                    new Node { 5,  new Node { 9 }, new Node { 3 } }
                              };

_При наличието на подходящ конструктор, този код ще създаде дървото:_

```
    11        
   /  \
  5    23 
 / \     \
3   9     42 
```