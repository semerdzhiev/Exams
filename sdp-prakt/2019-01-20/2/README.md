# Контролно 2

2019-01-21  
СДП-практикум

## Вариант 2

В задачите можете да използвате наготово контейнерите от STL (`array`, `vector`, `list`, `forward_list`, `stack` и `queue`, `map`, `set`, `unordered_set` и `unordered_map`). Всички останали структури от данни трябва да реализирате сами. Можете да използвате и помощните класове `pair` и `tuple`.

В случай, че ви потрябва хешираща функция, копирайте дадения по-долу код и използвайте наготово `getHash`. За да се компилира кодът, включете заглавния файл `<functional>`. Забележете, че връщаната стойност е от тип `size_t` (може да бъде произволно голяма). Ако трябва да я ограничите, за целите на изпита е достатъчно да я вземете по модул.

    template <typename T>
    size_t getHash(const T &element) {
        return std::hash<T>()(element);
    }

    size_t getHash(const char *str) {
        return std::hash<std::string>()(str);
    }


**Задача 1**. Напишете функция която приема един аргумент – корен на дърво, чиито възли могат да имат произволен брой деца. Всеки възел пази стойност -- цяло число.

Функцията трябва да намери онзи път от корена на дървото, до някое листо, който има най-малка сума на елементите в него. Този път трябва да се върне, като вектор от възлите в него. Ако има няколко такива пътя, може да се върне който и да е от тях.  Напишете кратка програма, която демонстрира работата на функцията върху примерно дърво. По-долу са дадени представянето на дървото и прототипът на функцията, която трябва да реализирате. Те трябва да са точно такива, както са показани тук.

    struct Node {
        int value;
        std::vector<Node> children;
    };

    std::vector<Node*> findCheapestPath(Node *root);


**Задача 2**. Напишете програма, която на входа си получава описанието на граф. Този граф е неориентиран, без тегла на дъгите си. След него ще бъде въведен индексът на връх от графа (A). Вашата програма трябва да отпечата, на един ред, всички върхове, които са достижими от A, а след него, на нов ред, всички, които НЕ СА достижими от A.

На входа на програмата ще се подадат, в следния ред:
* Цяло число N – брой върхове в графа (всеки от тях е число между 0 до N);
* Цяло число К – брой на ребрата в графа;
* K на брой реда, всеки от които съдържа две числа – индексите на върхове, между които има ребро в графа;
* Число A – индекс на връх в графа.


**Бонус задача** _(за онези от вас, който на първото контролно имат резултат <= 5т., тази задача носи до 2т.)_

Имплементирайте функция, която получава като аргумент корена на двоично дърво и определя дали то е двоично наредено дърво. Напишете кратка програма, която демонстрира работата на функцията върху примерно дърво. В нея покажете как функцията реагира на поне два положителни и един отрицателен пример.
По-долу са дадени представянето на дървото и прототипа на функцията, която трябва да реализирате. Те трябва да са точно такива, както са показани тук.

    struct Node {
        Node *left, *right;
        int value;
    };

    bool isBst(Node* root);

----

_Упътване: За създаването на примерни дървета не е нужно да разписвате клас или функции. Можете да се възползвате от това, че можете да ги създадете при инициализацията:_

    Node* test_tree = new Node{ 11, new Node { 23, new Node { 42 }, nullptr },
                                    new Node { 5,  new Node { 9 }, new Node { 3 } }
                              };

_При наличието на подходящ конструктор, този код ще създаде дървото:_

```
    11        
   /  \
  5    23 
 / \     \
3   9     42 
```