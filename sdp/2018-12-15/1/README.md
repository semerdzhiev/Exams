# Контролно 2

2018-12-15
СДП

## Вариант 1

В задачите можете да използвате наготово следните контейнери от STL: `array`, `vector`, `list`, `forward_list`, `stack` и `queue`. Всички останали структури от данни трябва да реализирате сами. Можете да използвате и помощните класове `pair` и `tuple`.

В случай, че ви потрябва хешираща функция, копирайте дадения по-долу код и използвайте наготово `getHash`. За да се компилира кодът, включете заглавния файл `<functional>`.

```cpp
template <typename T>
size_t getHash(const T &element) {
    return std::hash<T>()(element);
}

size_t getHash(const char *str) {
    return std::hash<std::string>()(str);
}
```

Забележете, че функцията връща число от тип `size_t`. То може да бъде произволно (вкл. много голямо). Ако реализирате собствен хеш, помислете как да ограничите стойността до размерите му, например като я вземете по модул.


**Задача 1.** Реализирайте контейнер, който съхранява числа и поддържа дадените по-долу операции. След всяка от тях е посочена сложността, с която трябва да работи.

* `Insert` – добавя нов елемент. О(log N)
* `Median` – връща медианата на съхранените в контейнера елементи. O(1)
* `Remove` – ако контейнерът не е празен, премахва медианата. В противен случай не прави нищо. O(log N).
* `Size` – връща броя на елементите в контейнера. O(1)
* `Empty` – връща истина, ако контейнерът е празен и лъжа в противен случай. O(1)

***Упътване:** използвайте две двоични пирамиди (binary heap) – една минимизираща и една максимизираща. При всяка Remove/Insert операция, се погрижете да направите така, че разликата в размерите им да бъде най-много единица.*

***Напомняне:** Нека е дадено множество от N елемента. Ако ги подредим в нарастващ ред, медианата ще бъде този от тях, който се намира в средата на сортираната редица. Казано по друг начин, медианата разделя елементите на множеството на две равни по обем части. Ако N е четно, в средата на сортираната редица ще имаме два елемента. Тогава (1) медианата се получава като тяхното средно аритметично, а (2) операцията `Remove` трябва да премахне един от тях; сами изберете кой. Например:*

* *За редицата `[1, 2, 3, 4, 5]`, медианата е `3`.*
* *За редицата `[1, 2, 3, 4, 5, 6]`, медианата е `3,5`; получава се от (3+4)/2.*

**Задача 2.** Напишете програма, в която се въвеждат данни за чудовища и типове атаки от компютърна игра и която след това може да отговаря на въпроси за тях.

На стандартния вход ще бъде подадено цяло число N > 0, следвано от описания на N вида различни атаки. Всяка атака се описва на отделен ред в следния формат:
* Име (символен низ, не повече от 30 символа);
* Цяло, неотрицателно число K;
* Списък с K на брой чудовища, които са уязвими към тази атака. Имената на чудовищата са не по-дълги от 30 символа.

След въвеждането на информацията за атаките и чудовищата, вашата програма ще трябва по зададено име на чудовище да каже кои са неговите уязвимости.

На стандартния вход ще получите цяло число M.
След него ще се въведат M имена на чудовища.
За всяко от тях трябва да изведете един ред, на който са изброени всички негови уязвимости.
Ако дадено чудовище няма уязвимости, да се изведе низа `"[none]"`.
Сложността на операцията, с която по име на чудовище X намирате и извеждате неговите уязвимости трябва да бъде най-много O(L) или по-добра, където L е броят на уязвимостите на X.

Входът на програмата ще отговаря на описанието и ще бъде валиден, няма нужда да го проверявате за коректност.

По-долу е дадено примерно изпълнение на програмата
```
5
shadow 4 Skeleton Warrior Monk Priest
arcane 5 Mage Warrior Monk Druid Beast
frost 4 Warrior Beast Archer Priest
physical 3 Mage Priest Archer
fire 2 Skeleton Warrior

4
Mage
> arcane physical
Skeleton
> fire shadow
Priest
> frost physical shadow
Ranger
> [none]
```