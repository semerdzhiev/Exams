/*
 * Примерно решение на задачата от първо контролно, група от 9:00, СДП 2018/2019.
 * 
 * Автор : Иван Филипов	
 */
 
#pragma once

#include <ctime>  // time_t, std::time()
#include <string> // std::string

// включваме имената от именното пространство std
using std::time;
using std::string;

// Клас представялващ "ПРОЗОРЕЦ" в браузeра
// Всеки прозорец можем да представим като 
// едносвързан списък от "раздели"
class window {
	
private:
	/* декларация на член данни и помощни структури */
	// структура представялваща един "РАЗДЕЛ"
	// тъй като външния свят може да не знае
	// за представянето на "прозорците", можем да скрием "раздела"
    struct tab {
    	
        string url;       // адрес на отворената в раздела страница
        time_t timestamp; // времево клеймо - кога е създаден разделът
        tab*   next_ptr;  // указател към следващия раздел
        // помощен констуктор за "раздел" с задължителен параметър "url"
        // текущото време можем да не подаваме, а да зададем параметър по подразбиране
        tab(const string& u, time_t ts = time(nullptr), tab* np = nullptr) :
        	url(u), timestamp(ts), next_ptr(np) { // всичката работа е в инициализиращия списък
        	// празно тяло
        }
		// всички останали "специални" методи грижещи се за живота на обектите "tab"
		// ще бъдат генерирани от компилаторът ако се използват, за нас стандартните им версии
		// са ОК, защото нямаме никакви динамични член данни, за които да се грижим
    };
    
    // можем да използваме синтактична "захар" от C++, инициализиране с дефолтни стойности на член данните
    // друг вариант е да използваме закоментирания по-долу конструктор  
    tab*   head_ptr = nullptr; // указател към първия "раздел" на прозореца
    size_t cur_size = 0;       // текущ размер, не е задължителен, но ни помага за статистиката при EXIT
	
	static const string default_url; // стринг за "url" по подразбиране, общ за всички обекти от класа "window"
	
public :
	/* грижа за живота на обектите от класа */
	
	// ако не използваме синтаксисът от по-горе :
	// window() : head_ptr(nullptr), cur_size(0) {};
	
	// чрез "=default" показваме, че сме съгласни с дефинирания от компилатора
	// дефолтен конструктор, който ще използва инициализациите направени горе
	window() = default;
	// в задачата не се изисква да можем да копираме "прозорците",
	// затова можем да обявим копи-конструктора и оператор= за забранени
	window& operator=(const window&) = delete;
	window(const window&)            = delete;
	
	// не трябва да забравяме, че в деструктора трябва да се погрижим за
	// динамичните данни, този тук сме отбелязали като "вграден - inline"
	~window() { clear(); }

private :
	/* помощни методи */
	// метод, който освобождава динамичната памет
	// за всички "раздели" след сочения от указателя first, включително
	// връща броя на "разрушените" "раздели"
	// методът не променя член данните на списъка
	size_t destroy_tabs_chain(tab* first);
	// метод, който отпечатва на стандартния изход всички
	// текущи "раздели"
	void print_tabs_formatted() const;
	
public :
	/* интерфейс на класа */
	// метод, освобождаващ раделените ресурси и зануляващ член данните
	void clear(); 
	// метод, който обработва заявка TAB, използваме дефолтния параметър
	// за по - лесно създаване на нови "прозорци"
	void tab_request(const std::string& url = default_url);
	// няколко "вградени" методи
	// връща размера
	size_t size() const { return cur_size; }
	// казва дали "прозорецът е празен"
	bool empty() const { return cur_size == 0; }
	// връща времевото клеймо на първия елемент, той е и най-старият отворен прозорец,
	// за това можем да го използваме при UPTIME
	time_t get_head_timestamp() const { return (empty()) ? time(nullptr) : head_ptr->timestamp; }
};
// имплементациите на "вградените" методи
// винаги са в "заглавните" файлове
inline
void window::clear() {
	
	destroy_tabs_chain(head_ptr);
	head_ptr = nullptr;
	cur_size = 0;
}

// клас представляващ "БРАУЗEРА"
// можем да го имплементираме като
// стек реализиран върху статичен масив
class browser {
	
private :
	/* декларация на член данни и помощни структури */
	// константа определяща максималния размер
	static const int MAX_WINDOW_COUNT = 256;
	// статичен масив от "прозорци"
	window windows[MAX_WINDOW_COUNT];
	// индекс на текущия прозорец ( върха на стека )
	size_t top = 0;
	// константа за това кога е създаден браузeра
	const time_t creation_timestamp = time(nullptr);
	
public :
	/* грижа за живота на обектите от класа */
	// тък като нямаме никакви динамични данни, можем
	// да оставим дефолтните версии създадени от компилатора
	browser()                          = default;
	browser(const browser&)            = default;
	browser& operator=(const browser&) = default;
	~browser()                         = default;
	
public :
	/* интерфейс на класа */
	// създава нов "прозорец" в браузъра
	void window_open();
	// затваря текущия прозорец
	void window_close();
	// отпечатва времето от командата UPTIME
	void print_uptime();
	// затваря браузъра - отпечатва статистиката
	void close();
	
	// достъп до текущия "прозорец" - константна версия
	// за да можем да викаме константните методи на "window"
	const window& get_current_window() const;
	// достъп до текущия "прозорец" - неконстантна версия
	// за да можем да променяме текущия "window"
	window& get_current_window();
	// казва дали браузърът е празен
	bool empty() const { return top == 0; }
};
